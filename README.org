* cl-naive-code-analyzer

Creates an index of code with a naive "who calls" info. 

* cl-naive-code-analyzer

cl-naive-code-analyzer is a Common Lisp library designed to statically analyze one or more Lisp projects by extracting function and macro definitions, call relationships, lambda lists, and variable usage directly from source code. It performs structural parsing using Eclector and stores analysis results for efficient querying across project boundaries. Its primary goals are to support AI-assisted context discovery, dead code detection, and future inference of architectural patterns — all without relying on runtime instrumentation or central in-memory indexes.

This code is pre ALPHA so use at own risk.

** Alternatives Availabe to [project name]

Could not find anything, but you are welcome to ping me if there is something.

** Design

The design of cl-naive-code-analyzer emphasizes static, persistent, and extensible Common Lisp source analysis without relying on runtime behavior. It parses source files using Eclector with custom stream tracking to capture precise boundaries for forms and metadata. Each top-level form is dispatched to an analyzer via a hash-based registry, allowing modular support for defun, defmethod, macros, and more — with a fallback analyzer handling unknown forms using lambda-list heuristics. The analysis results are stored persistently, enabling cross-project querying without re-parsing code. The system avoids global indexing state, instead relying solely on serialized per-form analysis records, making it robust, decoupled, and query-oriented from the ground up.

** Use Cases

Use Cases for cl-naive-code-analyzer:

 - AI Code Context: Retrieve relevant and related source code across multiple projects to provide meaningful context to AI tools like code assistants or reviewers.

 - Dead Code Detection: Identify unused functions, methods, or macros by analyzing call graphs and reference chains.

 - Code Navigation & Search: Build powerful IDE features like cross-referencing, jump-to-definition, or usage tracking across multi-project systems.

 - Dependency Analysis: Understand how functions and macros depend on one another for refactoring or modularization.

 - Documentation Extraction: Generate human-readable summaries or API docs from extracted form metadata, lambda lists, and docstrings.

 - Design Inference (Future): Analyze architecture-level patterns, usage conventions, or project design idioms based on symbolic structure.

These features make it useful for tooling, auditing, documentation, and AI-assisted development workflows.


** Documentation

[[file:docs/docs.org][Documentation]] can be found in the docs folder in the repository.


** Tutorials

Simple step by step [[file:docs/tutorials.org][tutorial(s)]] to get you started fast.

** How To(s)

How to do different things can be found [[file:docs/how-tos.org][here]].

** Dependencies

[Dependencies per ASDF]

** Supported CL Implementations

Should support all compliant implementations, no implementation specific code was used.

** Tests

To load and run the tests, clone the project and then:

#+BEGIN_SRC lisp
  (ql:quickload :cl-naive-code-analyzer.tests)

  (cl-naive-tests:report (cl-naive-tests:run))
#+END_SRC
